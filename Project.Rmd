---
title: "Final Project - Data Mining"
authors: "Dawid Michal Roch Móll, Jonathan Zinzan Salisbury Vega, Joan Sansó Pericàs, Joan Vilella Candia, Julián Wallis Medina"
date: Sys.Date()
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
library(dplyr)
library(ggdist)
library(tidyverse)
library(plotly)
library(networkD3)
library(scales)
library(reshape)
library(klaR)
library(countrycode)
library(ISLR)
library(rpart)
library(rpart.plot)

set.seed(999)
```

### Comentarios
- Casi todos son Full Time
- MIRAR OUTLIERS
- Nuevas columnas: 

## Exploratory Data Analysis

```{r}
df <- read.csv("salaries.csv", stringsAsFactors = TRUE)
summary(df)
str(df)
```

```{r}
anyNA(df)
```

```{r}
df$salary <- NULL

df$remote_ratio <- as.factor(df$remote_ratio)
levels(df$remote_ratio) <- list("Office" = 0, "Hybrid" = 50,  "Remote" = 100)

df$salary_group <- cut(df$salary_in_usd, c(0, 25000, 50000, 75000, 100000, 125000, 150000, 200000, 250000, 1000000))
df$salary_group <- as.factor(df$salary_group)
levels(df$salary_group) <- c("25k", "50k", "75k", "100k", "125k", "150k", "200k", "250k", "1M")
```

```{r}
# group df$employee_residence to different regions in the world. The data is in ISO 3166-1 alpha-2 format. Regions like North America, Europe, Asia, etc.
df$employee_region <- as.factor(df$employee_residence)
levels(df$employee_region) <- list(  
  "North America" = c("US", "CA", "MX"),   
  "South America" = c("AR", "BO", "BR", "CL", "CO", "EC", "PE", "PY", "UY", "VE"),   
  "Central America" = c("BZ", "CR", "DO", "GT", "HN", "NI", "PA", "PR", "SV"),
  "Europe" = c("AT", "AX", "BE", "BG", "CH", "CY", "CZ", "DE", "DK", "EE", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IS", "IT", "JE", "LT", "LU", "LV", "MD", "MT", "NL", "NO", "PL", "PT", "RO", "RU", "RS", "SE", "SI", "SK", "TR", "UA"),
  "Asia" = c("AE", "AF", "AM", "AZ", "BD", "BH", "BN", "CN", "GE", "HK", "ID", "IL", "IN", "IQ", "IR", "JO", "JP", "KG", "KH", "KP", "KR", "KW", "KZ", "LA", "LB", "LK", "MM", "MN", "MO", "MV", "MY", "NP", "OM", "PH", "PK", "QA", "SA", "SG", "SY", "TH", "TJ", "TM", "TW", "UZ", "VN", "YE"),   
  "Africa" = c("AO", "BF", "BI", "BJ", "BW", "CD", "CF", "CG", "CI", "CM", "CV", "DJ", "DZ", "EG", "EH", "ER", "ET", "GA", "GH", "GM", "GN", "GQ", "GW", "KE", "KM", "LR", "LS", "LY", "MA", "MG", "ML", "MR", "MU", "MW", "MZ", "NA", "NE", "NG", "RE", "RW", "SC", "SD", "SH", "SL", "SN", "SO", "ST", "SZ", "TD", "TG", "TN", "TZ", "UG", "YT", "ZA", "ZM", "ZW"), 
  "Oceania" = c("AU", "FJ", "FM", "GU", "KI", "MH", "MP", "NC", "NF", "NR", "NU", "NZ", "PF", "PG", "PN", "PW", "SB", "TK", "TO", "TV", "UM", "VU", "WF", "WS"))

df$company_region <- as.factor(df$company_location)
levels(df$company_region) <- list(  
  "North America" = c("US", "CA", "MX"),   
  "South America" = c("AR", "BO", "BR", "CL", "CO", "EC", "PE", "PY", "UY", "VE"),   
  "Central America" = c("BZ", "CR", "DO", "GT", "HN", "NI", "PA", "PR", "SV"),
  "Europe" = c("AT", "AL", "AX", "BE", "BG", "CH", "CY", "CZ", "DE", "DK", "EE", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IS", "IT", "JE", "LT", "LU", "LV", "MD", "MT", "NL", "NO", "PL", "PT", "RO", "RU", "RS", "SE", "SI", "SK", "TR", "UA"),
  "Asia" = c("AE", "AF", "AM", "AZ", "BD", "BH", "BN", "CN", "GE", "HK", "ID", "IL", "IN", "IQ", "IR", "JO", "JP", "KG", "KH", "KP", "KR", "KW", "KZ", "LA", "LB", "LK", "MM", "MN", "MO", "MV", "MY", "NP", "OM", "PH", "PK", "QA", "SA", "SG", "SY", "TH", "TJ", "TM", "TW", "UZ", "VN", "YE"),   
  "Africa" = c("AO", "BF", "BI", "BJ", "BW", "CD", "CF", "CG", "CI", "CM", "CV", "DJ", "DZ", "EG", "EH", "ER", "ET", "GA", "GH", "GM", "GN", "GQ", "GW", "KE", "KM", "LR", "LS", "LY", "MA", "MG", "ML", "MR", "MU", "MW", "MZ", "NA", "NE", "NG", "RE", "RW", "SC", "SD", "SH", "SL", "SN", "SO", "ST", "SZ", "TD", "TG", "TN", "TZ", "UG", "YT", "ZA", "ZM", "ZW"), 
  "Oceania" = c("AU", "AS", "FJ", "FM", "GU", "KI", "MH", "MP", "NC", "NF", "NR", "NU", "NZ", "PF", "PG", "PN", "PW", "SB", "TK", "TO", "TV", "UM", "VU", "WF", "WS"))

summary(df)
```

```{r}
aux <- data.frame(matrix(0, nrow = length(levels(df$company_region)), ncol = length(levels(df$company_region))))
colnames(aux) <- levels(df$company_region)
rownames(aux) <- levels(df$company_region)

for (i in 1:nrow(aux)) {
  for (j in 1:ncol(aux)) {
    aux[i, j] <- length(which(df$company_region == colnames(aux)[j] & df$employee_region == rownames(aux)[i]))
  }
}

data_long <- aux %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")

nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

sankeyNetwork(Links = data_long, Nodes = nodes,
                     Source = "IDsource", Target = "IDtarget",
                     Value = "value", NodeID = "name", 
                     sinksRight=FALSE, nodeWidth=40, fontSize=13, nodePadding=20)
```

```{r}
levels(factor(df$job_title))  
```

```{r}
df$industry <- ifelse( grepl("data", df$job_title, ignore.case = T), "DATA", "OTHER")
df$industry <- ifelse( grepl("machine", df$job_title, ignore.case = T), "ML/AI", df$industry)
df$industry <- ifelse( grepl("ML", df$job_title, ignore.case = T), "ML/AI", df$industry)
df$industry <- ifelse( grepl("AI", df$job_title, ignore.case = T), "ML/AI", df$industry)
df$industry <- as.factor(df$industry)

df$boss <- ifelse(grepl("head", df$job_title, ignore.case = T), TRUE, FALSE)
df$boss <- ifelse(grepl("lead", df$job_title, ignore.case = T), TRUE, df$boss)
df$boss <- ifelse(grepl("principal", df$job_title, ignore.case = T), TRUE, df$boss)
df$boss <- ifelse(grepl("director", df$job_title, ignore.case = T), TRUE, df$boss)

df$role <- ifelse(grepl("scientist", df$job_title, ignore.case = T), "SCIENTIST", "OTHER")
df$role <- ifelse(grepl("engineer", df$job_title, ignore.case = T), "ENGINEER", df$role)
df$role <- ifelse(grepl("analyst", df$job_title, ignore.case = T), "ANALYST", df$role)
df$role <- ifelse(grepl("manager", df$job_title, ignore.case = T), "MANAGER", df$role)
df$role <- ifelse(grepl("architect", df$job_title, ignore.case = T), "ARCHITECT", df$role)
df$role <- ifelse(grepl("developer", df$job_title, ignore.case = T), "DEVELOPER", df$role)
df$role <- as.factor(df$role)

df$research <- ifelse(grepl("research", df$job_title, ignore.case = T), TRUE, FALSE)

summary(df)

```
```{r}
mean(df$salary_in_usd)
mean(df[df$boss == 'NO', 'salary_in_usd'])
mean(df[df$boss == 'YES', 'salary_in_usd'])
```

```{r}
numerics_names <- colnames(df[, sapply(df, is.numeric)])
factors_names <- colnames(df[, sapply(df, is.factor)])

for (i in 1:length(numerics_names)){
  print(ggplot(df, aes_string(x= numerics_names[i])) +
    ggdist::stat_halfeye(
      adjust=0.5,
      justification = -.2,
      .width=0
    ) +
    geom_boxplot(
      width = .1,
      alpha = 0.5
    ) +
     labs(title=paste("Distribution and boxplot of",numerics_names[i]), y="count"))
}

for (i in 1:length(factors_names)){
  print(ggplot(df, aes_string(x= factors_names[i])) +
    geom_bar()+
     labs(title=paste("Histogram of",factors_names[i]),y="count"))
}
```

```{r}
plot(df$employee_residence, df$salary_in_usd, xlab="Employee Residence", ylab="Salary in USD")
plot(df$company_size, df$salary_in_usd, xlab="Company Size", ylab="Salary in USD")
plot(df$company_location, df$salary_in_usd, xlab="Company Location", ylab="Salary in USD")
plot(df$experience_level, df$salary_in_usd, xlab="Experience Level", ylab="Salary in USD")
plot(df$remote_ratio, df$salary_in_usd, xlab="Remote Ratio", ylab="Salary in USD")
```

```{r}

y_2020 <- df[df$work_year == 2020,]
y_2021 <- df[df$work_year == 2021,]
y_2022 <- df[df$work_year == 2022,]

y_2020 <- y_2020 %>% group_by(remote_ratio) %>% summarise(count = n())
y_2021 <- y_2021 %>% group_by(remote_ratio) %>% summarise(count = n())
y_2022 <- y_2022 %>% group_by(remote_ratio) %>% summarise(count = n())

y_2020$percentage <- y_2020$count / sum(y_2020$count) * 100
y_2021$percentage <- y_2021$count / sum(y_2021$count) * 100
y_2022$percentage <- y_2022$count / sum(y_2022$count) * 100

y_2020$work_year <- 2020
y_2021$work_year <- 2021
y_2022$work_year <- 2022

y <- rbind(y_2020, y_2021, y_2022)

ggplot(y, aes(x = work_year, y = percentage, group = remote_ratio, color = remote_ratio)) + geom_line() + geom_point() + labs(x = "Work Year", y = "Percentage of Remote Ratio", title = "Remote Ratio by Work Year") + theme(plot.title = element_text(hjust = 0.5))
```

# Questions

## 1. 
## 2. 
## 3. Can we predict an employee's salary based on their job title, experience level, and location using machine learning algorithms?

```{r}

```

## For us, students who are now finishing their degree. What is the best combination (based on salary)?

```{r}
# df_Q7 <- df
# # Make a graphic where experience_level = EN, y axis = salary_in_usd, x axis = country
# df_Q7 <- df_Q7[df_Q7$experience_level == 'EN',]
# df_Q7 <- df_Q7[df_Q7$remote_ratio == '0%',]
# df_Q7 <- df_Q7[df_Q7$boss == 'NO',]
# df_Q7 <- df_Q7[df_Q7$research == FALSE,]
# df_Q7 <- df_Q7[df_Q7$role == 'DEVELOPER',]
# df_Q7 <- df_Q7[df_Q7$work_year == 2022,]
# df_Q7 <- df_Q7[df_Q7$job_title == 'Software Engineer',]
# df_Q7 <- df_Q7[df_Q7$company_industry == 'Information Technology and Services',]
# df_Q7 <- df_Q7[df_Q7$company_sector == 'Information Technology',]
# 
# plot(df$remote_ratio, df$salary_in_usd, xlab="Remote Ratio", ylab="Salary in USD")
# 
# # Make a graphic where x axis = region, y axis = salary_in_usd
# plot(df$employee_region, df$salary_in_usd, xlab="employee_region", ylab="Salary in USD")
```

## 4. How much should the salary increase be when you get promoted to a higher Experience Level? (according to similar colleagues with the same job area).

This could be useful for employees that are going to recieve a promotion, and want
to know how much they should get paid for their new position.
It could also be useful for employers that want to know how much they should offer
new hires or promoting employees.

```{r}
f <- ggplot(df, aes(x=reorder(experience_level,salary_in_usd), y=salary_in_usd))+
     geom_boxplot()+
     ggtitle("Salary Distribution for each experience level") + ylab("Salary (USD)") + xlab("")
f
```
As we can see, from ENtry level to EXecutive level, as the experience increases, the larger the average salary gets. Lets see if we can find, using clustering, 3 zones for each


```{r}
set.seed(42)
df_split_industry <- split(df, df$industry)
names(df_split_industry) <- c("df_data", "df_ai", "df_other")
list2env(df_split_industry, envir = .GlobalEnv)

get_average_level_salary <- function(dFrame){
  mean_en = mean(dFrame[dFrame$experience_level=="EN","salary_in_usd"])
  mean_mi = mean(dFrame[dFrame$experience_level=="MI","salary_in_usd"])
  mean_se = mean(dFrame[dFrame$experience_level=="SE","salary_in_usd"])
  mean_ex = mean(dFrame[dFrame$experience_level=="EX","salary_in_usd"])
  ret = data.frame(c("EN","MI","SE","EX"),c(mean_en, mean_mi, mean_se, mean_ex))
  colnames(ret) <- c("Experience_Level","Average_Salary")
  ret$Experience_Level = factor(ret$Experience_Level, levels = c("EN","MI","SE","EX"))
  return(ret)
}

data_avg = get_average_level_salary(df_data)
ai_avg = get_average_level_salary(df_ai)
other_avg = get_average_level_salary(df_other)
```

```{r}

custom_line_plot <- function(datos,avgs, title){
  plot1 <- ggplot()+
            geom_violin(data=datos, aes(x=reorder(experience_level,salary_in_usd), y = salary_in_usd))+ 
  geom_line(data=avgs,aes(x=Experience_Level, y=Average_Salary, group=1))+
  geom_point(data=avgs,aes(x=Experience_Level, y=Average_Salary, group=1))+
  geom_text(data=avgs,aes(x=Experience_Level, y=Average_Salary, label = round(Average_Salary,0)) ,hjust=-0.2, vjust=-1)+
  scale_y_continuous(breaks = scales::pretty_breaks(n = 15))+
  labs(title=title)
  plot1
}

custom_line_plot(df_data,data_avg,"Data Industry")
custom_line_plot(df_ai,ai_avg,"AI/ML Industry")
custom_line_plot(df_other, other_avg,"Other Industries")

```



## 5. Do bigger companies pay more to their employees?
## 6. 
 
## 7. Can we predict which employees are at risk of leaving their company?

This could be useful for companies who want to retain their top talent and for employees that are underpaid. We could use different factors such to determine which employees are underpaid compared to their peers.

To answer this questions we will use two different techniques: Clustering and regression.

The following features will be used:
 - Experience level
 - Employment type
 - Industry
 - Employee region
 - Role
 - Remote_ratio
 - Boss
 - Research
 - Company size

### Clustering

First we create a separate dataframe for the variables we will use.
```{r}
# Select the variables to use in the clustering analysis
df_vars <- dplyr::select(df, experience_level, employment_type, company_size, industry, employee_region, boss, research, role, remote_ratio)
#                     
# df_vars$experience_level <- as.numeric(df_vars$experience_level)
# df_vars$industry <- as.numeric(df_vars$industry)
# df_vars$employment_type <- as.numeric(df_vars$employment_type)
# df_vars$company_size <- as.numeric(df_vars$company_size)
# df_vars$employee_region <- as.numeric(df_vars$employee_region)
# df_vars$role <- as.numeric(df_vars$role)
# df_vars$boss <- as.numeric(df_vars$boss)
# df_vars$research <- as.numeric(df_vars$research)
# df_vars$remote_ratio <- as.numeric(df_vars$remote_ratio)
# 
# # Standardize the variables
# df_vars <- scale(df_vars)

```

Let s find find the elbow in our plot, to find the "best" k for the kmodes algorithm
```{r}
# results <- data.frame(k = integer(), WCSS = double())
# 
# # Loop through a range of values for k
# for (k in 2:40) {
#   # Run the k-means clustering algorithm
#   km <- kmodes(df_vars, k, iter.max = 50)
#   # Store the results in the data frame
#   results <- rbind(results, data.frame(k = k, WCSS = sum(km$withindiff^2)))
# }
# 
# # Plot the WCSS values for each value of k
# ggplot(results, aes(x = k, y = WCSS)) +
#   geom_line() +
#   geom_point() +
#   labs(x = "Number of clusters (k)", y = "WCSS")
```


```{r}
# Perform k-means clustering with n clusters
kmodes_results <- kmodes(df_vars, 20)

df_Q7 <- df
# Add the cluster labels to the original data
df_Q7$cluster <- kmodes_results$cluster

# Inspect the clusters
group_by(df_Q7, cluster) %>%
  summarize(mean_salary = mean(salary_in_usd))
```

```{r}
fig1 <- plot_ly(df_Q7, x = ~as.numeric(employee_region), y = ~as.numeric(industry), z = ~as.numeric(experience_level), color = ~cluster)
fig1 <- fig1 %>% add_markers()

axx <- list(ticketmode = 'array', title="Employee region", ticktext = levels(df$employee_region),  tickvals = c(1,2,3,4,5,6,7),  range = c(1,7), tickangle = 25)
axy <- list(ticketmode = 'array', title="Industry", ticktext = levels(df$industry),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)
axz <- list(ticketmode = 'array', title="Experience level", ticktext = levels(df$experience_level),  tickvals = c(1,2,3,4),  range = c(1,4), tickangle = 45)

fig1 <- fig1 %>% layout(scene = list(xaxis = axx, yaxis = axy, zaxis = axz))
fig1


fig2 <- plot_ly(df_Q7, x = ~as.numeric(role), y = ~as.numeric(industry), z = ~as.numeric(remote_ratio), color = ~cluster)
fig2 <- fig2 %>% add_markers()

axx <- list(ticketmode = 'array', title="Role", ticktext = levels(df$role),  tickvals = c(1,2,3,4,5,6,7),  range = c(1,7), tickangle = 25)
axy <- list(ticketmode = 'array', title="Industry", ticktext = levels(df$industry),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)
axz <- list(ticketmode = 'array', title="Remote ratio", ticktext = levels(df$remote_ratio),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)

fig2 <- fig2 %>% layout(scene = list(xaxis = axx, yaxis = axy, zaxis = axz))
fig2


fig3 <- plot_ly(df_Q7, x = ~as.numeric(role), y = ~as.numeric(industry), z = ~as.numeric(remote_ratio), color = ~cluster)
fig3 <- fig3 %>% add_markers()

axx <- list(ticketmode = 'array', title="Role", ticktext = levels(df$role),  tickvals = c(1,2,3,4,5,6,7),  range = c(1,7), tickangle = 25)
axy <- list(ticketmode = 'array', title="Industry", ticktext = levels(df$industry),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)
axz <- list(ticketmode = 'array', title="Remote ratio", ticktext = levels(df$remote_ratio),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)

fig3 <- fig3 %>% layout(scene = list(xaxis = axx, yaxis = axy, zaxis = axz))
fig3

```

```{r}
mean_salary <- tapply(df_Q7$salary_in_usd, df_Q7$cluster, mean)
# View the mean salary for each level of the experience_level variable
df_Q7$salary_difference_kmodes <- 0
df_Q7$predicted_salary_kmodes <-0

for (i in 1:nrow(df_Q7)) {
  cluster_index = match(df_Q7$cluster[i], names(mean_salary))
  df_Q7$salary_difference_kmodes[i] <- df_Q7$salary_in_usd[i] - mean_salary[cluster_index]
  df_Q7$predicted_salary_kmodes[i] <- mean_salary[cluster_index]
}

underpaid_employees_kmodes <- df_Q7[df_Q7$salary_difference_kmodes < 0, ]
overpaid_employees_kmodes <- df_Q7[df_Q7$salary_difference_kmodes > 0, ]

underpaid_employees_kmodes <- underpaid_employees_kmodes[order(underpaid_employees_kmodes$salary_difference_kmodes), ]
overpaid_employees_kmodes <- overpaid_employees_kmodes[order(overpaid_employees_kmodes$salary_difference_kmodes, decreasing = TRUE), ]

# View the underpaid and overpaid employees
head(underpaid_employees_kmodes, n = 10)
head(overpaid_employees_kmodes, n=10)
```

```{r}
model <- lm(salary_in_usd ~ experience_level + employment_type + employee_region + company_size + industry + role + boss + research + remote_ratio, data = df_Q7)
summary(model)
```

```{r}
df_Q7$predicted_salary_lm  <- predict(model, newdata = df_Q7)
df_Q7$salary_difference_lm <- df_Q7$salary_in_usd - df_Q7$predicted_salary_lm

# Use the salary difference column to identify underpaid and overpaid employees
underpaid_employees_lm <- df_Q7[df_Q7$salary_difference_lm < 0, ]
overpaid_employees_lm <- df_Q7[df_Q7$salary_difference_lm > 0, ]

underpaid_employees_lm <- underpaid_employees_lm[order(underpaid_employees_lm$salary_difference_lm), ]
overpaid_employees_lm <- overpaid_employees_lm[order(overpaid_employees_lm$salary_difference_lm, decreasing = TRUE), ]

# View the underpaid and overpaid employees
head(underpaid_employees_lm, n = 10)
head(overpaid_employees_lm, n=10)
```

```{r}
df_Q7$kmodes_ratio_error <- ((df_Q7$predicted_salary_kmodes / df_Q7$salary_in_usd)-1)*100
df_Q7$lm_ratio_error <- ((df_Q7$predicted_salary_lm / df_Q7$salary_in_usd)-1)*100

summary(df_Q7[, c("kmodes_ratio_error","lm_ratio_error")])
quantiles_kmodes <- quantile(df_Q7$kmodes_ratio_error, c(0.25,0.75))
quantiles_lm <- quantile(df_Q7$lm_ratio_error, c(0.25,0.75))

```

```{r}
df_Q7 <- df_Q7[order(df_Q7$salary_in_usd),]
# Add a column to the dataframe with a sequence of integers
x <- 1:nrow(df_Q7)

df_Q7$status_lm <- ifelse(df_Q7$lm_ratio_error < quantiles_kmodes[1], "Overpaid", 
                      ifelse(df_Q7$lm_ratio_error < quantiles_kmodes[2], "Normal", "Underpaid"))

df_Q7$status_kmodes <- ifelse(df_Q7$kmodes_ratio_error < quantiles_lm[1], "Overpaid", 
                      ifelse(df_Q7$kmodes_ratio_error < quantiles_lm[2], "Normal", "Underpaid"))
```

```{r}
ggplot(df_Q7, aes(x = x, y = salary_in_usd)) +
        geom_point(aes(y = salary_in_usd), size= 2, shape = 20) +
        geom_point(aes(y = predicted_salary_lm, color = status_lm), size =2,  shape = 20, alpha = 0.9) + 
        scale_color_manual(
          values = c("Overpaid" = "red", "Underpaid" = "orange", "Normal" = "green"), 
          labels = c('Normal', 'Overpaid', 'Underpaid'),
          aesthetics = c("colour", "fill"), 
          name = "Consideration") +
        ggtitle("Plot of salary and predicted salaries using Linear Regression") +
        ylab("Salary in USD") +
        scale_y_continuous(labels = label_comma(), breaks = scales::pretty_breaks(n = 10))
        

ggplot(df_Q7, aes(x = x, y = salary_in_usd)) +
        geom_point(aes(y = salary_in_usd), size= 2, shape = 20) +
        geom_point(aes(y = predicted_salary_kmodes, color = status_kmodes), size =2,  shape = 20, alpha = 0.9) + 
        scale_color_manual(
          values = c("Overpaid" = "red", "Underpaid" = "orange", "Normal" = "green"), 
          labels = c('Normal', 'Overpaid', 'Underpaid'),
          aesthetics = c("colour", "fill"),
          name = "Consideration") +
        ggtitle("Plot of salary and predicted salaries using Clustering") +
        ylab("Salary in USD") +
        labs(fill="Consideration") +
        scale_y_continuous(labels = label_comma(), breaks = scales::pretty_breaks(n = 10))


```

```{r}
df_Q7$status_lm <- as.factor(df_Q7$status_lm)
df_Q7$status_kmodes <- as.factor(df_Q7$status_kmodes)


ct <- table(df_Q7$status_lm,df_Q7$status_kmodes)
ct <- ct[c(3,1,2),c(3,1,2)]
ct <- melt(ct)
colnames(ct) <- c("LinearRegression", "Clustering", "Count")

ggplot(ct, aes(x = LinearRegression, y = Clustering, fill = Count)) +
  geom_tile() +
  scale_fill_gradient2(low = "#075AFF", mid = "#FFFFCC", high = "#FF0000") +
  geom_text(aes(label = Count), color = "black", size = 4) +
  coord_fixed() +
  ggtitle("Comparison between Clustering and Linear Regression") 

```

```{r}
underpaid_lm <- df_Q7[df_Q7$status_lm=="Underpaid",]
overpaid_lm <- df_Q7[df_Q7$status_lm=="Overpaid",]

underpaid_kmodes <- df_Q7[df_Q7$status_kmodes =="Underpaid",]
overpaid_kmodes  <- df_Q7[df_Q7$status_kmodes =="Overpaid",]
```

```{r}

variables <- c("experience_level", "remote_ratio", "salary_group", "employee_region", "company_region", "role", "boss", "research", "company_size", "industry")

for (i in 1:length(variables)){
  ratio_df <- table(df_Q7[, c(variables[i])])/nrow(df_Q7)
  ratio_up_lm <- table(underpaid_lm[, c(variables[i])])/nrow(underpaid_lm)
  ratio_op_lm <- table(overpaid_lm[, c(variables[i])])/nrow(overpaid_lm)

  # plot them in such a way that they can be compared
  df_long_lm <- melt(data.frame(ratio_up_lm, ratio_df, ratio_op_lm))
  
  ratio_up_kmodes <- table(underpaid_kmodes[, c(variables[i])])/nrow(underpaid_kmodes)
  ratio_op_kmodes <- table(overpaid_kmodes[, c(variables[i])])/nrow(overpaid_kmodes)

  # plot them in such a way that they can be compared
  df_long_kmodes <- melt(data.frame(ratio_up_kmodes, ratio_df, ratio_op_kmodes))

  print(ggplot(data = df_long_lm, aes(x = variable, y = value , fill = Var1, label = round(value, 2))) +
    geom_bar(stat = "identity", position = "fill") +
    geom_text(size = 3, position = position_stack(vjust = 0.5)) +
    scale_x_discrete(labels = c("Freq"= "Underpaid", "Freq.1"= "Normal", "Freq.2" = "Overpaid")) +
    labs(fill=variables[i], title=paste("Stacked percent bar chart of ",variables[i], " (LM)"), x="Consideration", y = "%"))
  
   print(ggplot(data = df_long_kmodes, aes(x = variable, y = value , fill = Var1, label = round(value, 2))) +
    geom_bar(stat = "identity", position = "fill") +
    geom_text(size = 3, position = position_stack(vjust = 0.5)) +
    scale_x_discrete(labels = c("Freq"= "Underpaid", "Freq.1"= "Normal", "Freq.2" = "Overpaid")) +
    labs(fill=variables[i], title=paste("Stacked percent bar chart of ",variables[i], " (Clustering)"), x="Consideration", y = "%"))
}

```

## 8. What is more worth, to work in the office at your region or remotely in another region?

First we should have a look at how much are employees paid while working in the office at their same region.

```{r}
df_filtered <- filter(df, employee_region == company_region)

print(ggplot(aes(x = employee_region, y = salary_in_usd, fill=employee_region), data = df_filtered) +
    stat_summary(fun=mean, geom="bar", position = "stack") +
    stat_summary(aes(label=round(after_stat(y),2)), fun.y=mean, geom="text", size=3, vjust = -0.5) + 
    xlab("Region") + labs(title="Salary of any work in the same Region"))
```

Here we can see that most of the Regions are underpaid for office work compared to North America, especially the rest of america.

Could they earn more if they work remotely for another Region?

Lets have a look at how much do companies in each region pay for Remote work.


```{r}
df_filtered <- filter(df, employee_region != company_region & remote_ratio == "Remote")

print(ggplot(aes(x = company_region, y = salary_in_usd, fill=company_region), data = df_filtered) +
    stat_summary(fun=mean, geom="bar", position = "stack") +
    stat_summary(aes(label=round(after_stat(y),2)), fun.y=mean, geom="text", size=3, vjust = -0.5) + 
    xlab("Region") + labs(title="Salary of Remote work in another Region"))
```
We can see that by average North America and Europe are close, while the rest are much lower, especially Asia.
The regions that do not appear, don't employ remote workers from another regions.

In relation to the high paying, we can see that USA pays less for remote work, than for office work. On the other hand in Europe the salary is on the same level for remote and office work.

Now we can focus on answering the question. 

```{r}
aux <- data.frame(matrix(0, nrow = length(levels(df$company_region)), ncol = length(levels(df$company_region))))
colnames(aux) <- levels(df$company_region)
rownames(aux) <- levels(df$company_region)

for (i in 1:nrow(aux)) {
  max = 0
  for (j in 1:ncol(aux)) {
    df_filtered <- filter(df, company_region == colnames(aux)[j] & employee_region == rownames(aux)[i])
    aux[i, j] <- mean(df_filtered$salary_in_usd)
  }
}

aux_clean <- data.frame(matrix(0, nrow = length(levels(df$company_region)), ncol = length(levels(df$company_region))))
colnames(aux_clean) <- levels(df$company_region)
rownames(aux_clean) <- levels(df$company_region)

aux <- replace(aux, is.na(aux), 0)

for (i in 1:nrow(aux_clean)) {
  max <- 0
  for (j in 1:ncol(aux_clean)) {
    #if(i == j) {
     # aux_clean[i,j] <- aux[i,j]
    #} else 
    if(aux[i,j]>max){
      max <- aux[i,j]
      aux_clean[i,j] <- aux[i,j]
    }
  }
}


data_long <- aux_clean %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")

nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

sankeyNetwork(Links = data_long, Nodes = nodes,
                     Source = "IDsource", Target = "IDtarget",
                     Value = "value", NodeID = "name", 
                     sinksRight=FALSE, nodeWidth=40, fontSize=13, nodePadding=20)
```


## 9. 
## 10. 
## 11. 
## 12.
## 13. Can we identify salary disparities based on residence and other demographic factors?

For this we'll use visualization techniques with the ggplot library. The width of the boxes depends on the amount of samples each class/value has so we can extract better conclusions out of them.
```{r}
ggplot(df, aes(x = as.factor(work_year), y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the work year", x = "Year", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = experience_level, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the experience level", x = "Experience level", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = employment_type, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the employment type", x = "Employment type", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = employee_region, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the employee region of residence", x = "Region of residence", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = company_size, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the company size", x = "Company size", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = role, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the role", x = "Role", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = industry, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the industry", x = "Industry", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = boss, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on whether the employee has a leadership position", x = "Has a leadership position", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = research, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on whether the employee participates in research projects", x = "Works in research projects", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())
```

Let's go through the different plots and check if we can identify any disparity:

  - Work year: we can observe how the salaries seem to be growing year by year - mostly in 2022. Probably due to the inflation rates. Further we can check which is the amount of growth in salaries discounting the inflation.
  - Experience level: as expected, more experienced professionals earn a higher salary.
  - Employment type: we can't say much about contract, freelance or part time jobs since the amount of samples we have is quite reduced; but probably contracts generate higher revenue than a full time job.
  - Employee region of residence: we can observe how the income in north american countries is higher than in the other regions, can't say much about other regions apart of NA and Europe since the dataset is mostly composed of these regions data.
  - Company size: we can clearly see that smaller companies usually offer lower salaries while medium and large companies have higher wages. The difference between medium and large ones is mostly the same but the impressive salaries usually come from large enterprises (makes sense think about Google, Meta, Netflix, Amazon...).
  - Role: better paid roles are architects, engineers, managers and scientists while developers have the lower wages from all the roles.
  - Industry: in terms of the company industry we can't say much about it since data and ML/AI companies are quite similar when it comes to wages.
  - Leadership position: we can clearly observe how having a leadership position in the company usually implies a higher salary in return.
  - Involved in research projects: on the other hand, participating in research projects seems to be not so interesting, at least from the financial perspective, since most other people earn higher salaries than the ones that participate in this kind of projects.

```{r}
increase = (mean(df[df$work_year == 2022, 'salary_in_usd'])/mean(df[df$work_year == 2021, 'salary_in_usd'])) - 1
net_increase = increase - 0.077 # official inflation rate in 2022 in the US
net_increase
```

It seems like the increase in salaries between 2021 and 2022 is not explained only with the inflation, since the increase has been of over a 34% in total and the official 2022 inflation rate that the US government gives is ay 7.7%. The net salary increase taking that into account (most samples of the data are US based), net salaries have increased a 27.17%.

## 14. Can we predict an employee's experience level based on their salary and job title? Using classification algorithms, we could build a model that predicts an employee's experience level based on their salary and job title. This could be useful for employees and job seekers who want to understand what experience level they can expect to be paid for a given salary and job title. We could also include other factors, such as location and company size, to improve the accuracy of the model.

For this we'll use a Decision Tree since we are interested in having a clear way to visualize and understand the result. We want to classify the experience level of employees based on attributes such as their role, industry for which they work, salary, etcetera.

BASE MODEL: Predict experience level with only salary and job title; since job title is a factor with numerous levels industry and role will be used instead.

```{r}
df14 = df[, c("industry", "role", "salary_in_usd", "experience_level")]
# df14_sample <- sample(c(TRUE, FALSE), nrow(df14), replace=TRUE, prob=c(0.7,0.3))
# df14_train  <- df14[df14_sample, ]
# df14_test   <- df14[!df14_sample, ]
dt14 = rpart(experience_level~., data=df14)
rpart.plot(dt14)
```

ADVANCED MODEL: Predict experience level with all of the variables available (apart from those which factor level exceeds 32).

```{r}
df14v2 = df[ , -which(names(df) %in% c("job_title", "work_year", "ID", "company_location", "employee_residence", "employee_region", "company_region", "salary_group", "salary_currency", "remote_ratio"))]
# df14_samplev2 <- sample(c(TRUE, FALSE), nrow(df14v2), replace=TRUE, prob=c(0.7,0.3))
# df14_trainv2  <- df14v2[df14_samplev2, ]
# df14_testv2   <- df14v2[!df14_samplev2, ]
summary(df14v2)
dt14v2 = rpart(experience_level~., data=df14v2)
rpart.plot(dt14v2)
```

## 15. 

## INTENTO FALLIDO. Join cost of living index dataset into problem dataset

We only want the country and the cost of living and we delete Kosovo from the list since it is a disputed territory and luckily enough we don't have any Kosovo related data in our dataset
```{r}
cost_of_living_df = read.csv("Cost_of_Living_Index_2022.csv", stringsAsFactors = TRUE)[-67, c(2,3)]
cost_of_living_df = setNames(cost_of_living_df, c("country", "cost_of_living_index"))
cost_of_living_df$country = countrycode(cost_of_living_df$country, origin = 'country.name', destination = 'iso2c')
```

Add the cost of living index columns of the employee residence and the company location deleting those rows that contain either American Samoa or Aaland Islands, since we don't have information about the cost of living index in these countries.

```{r}
dfN<-subset(df, employee_residence!="AX" & employee_residence!="AS" & company_location!="AX" & company_location!="AS")
dfN$cost_of_living_index_employee = rep(0, nrow(dfN))
dfN$cost_of_living_index_company = rep(0, nrow(dfN))
for(i in 1:nrow(dfN)) {
  country_employee = dfN[i, ]$employee_residence
  country_company = dfN[i, ]$company_location
  index_employee =  cost_of_living_df[as.character(cost_of_living_df$country)==as.character(country_employee), ]$cost_of_living_index
  index_company = cost_of_living_df[as.character(cost_of_living_df$country)==as.character(country_company), ]$cost_of_living_index
  dfN[i,]$cost_of_living_index_employee = index_employee
  dfN[i,]$cost_of_living_index_company = index_company
}
```

Let's find the employees that live in a cheaper country than the one that they work for.

```{r}
subset(dfN, cost_of_living_index_employee>cost_of_living_index_company)
subset(dfN, as.character(company_location)!=as.character(employee_residence))
```
