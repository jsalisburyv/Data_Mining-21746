---
title: "Final Project - Data Mining"
authors: "Dawid Michal Roch Móll, Jonathan Zinzan Salisbury Vega, Joan Sansó Pericàs, Joan Vilella Candia, Julián Wallis Medina"
date: Sys.Date()
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
library(dplyr)
library(ggdist)
library(tidyverse)
library(plotly)
library(networkD3)
library(scales)
library(reshape)


set.seed(999)
```

### Comentarios
- Casi todos son Full Time
- MIRAR OUTLIERS
- Nuevas columnas: 

## Exploratory Data Analysis

```{r}
df <- read.csv("salaries.csv", stringsAsFactors = TRUE)
summary(df)
str(df)
```

```{r}
anyNA(df)
```

```{r}
df$ID <- seq.int(nrow(df))
df$salary <- NULL

df$remote_ratio <- as.factor(df$remote_ratio)
levels(df$remote_ratio) <- list("Office" = 0, "Hybrid" = 50,  "Remote" = 100)

df$salary_group <- cut(df$salary_in_usd, c(0, 25000, 50000, 75000, 100000, 125000, 150000, 200000, 250000, 1000000))
df$salary_group <- as.factor(df$salary_group)
```

```{r}
# group df$employee_residence to different regions in the world. The data is in ISO 3166-1 alpha-2 format. Regions like North America, Europe, Asia, etc.
df$employee_region <- as.factor(df$employee_residence)
levels(df$employee_region) <- list(  
  "North America" = c("US", "CA", "MX"),   
  "South America" = c("AR", "BO", "BR", "CL", "CO", "EC", "PE", "PY", "UY", "VE"),   
  "Central America" = c("BZ", "CR", "DO", "GT", "HN", "NI", "PA", "PR", "SV"),
  "Europe" = c("AT", "AX", "BE", "BG", "CH", "CY", "CZ", "DE", "DK", "EE", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IS", "IT", "JE", "LT", "LU", "LV", "MD", "MT", "NL", "NO", "PL", "PT", "RO", "RU", "RS", "SE", "SI", "SK", "TR", "UA"),
  "Asia" = c("AE", "AF", "AM", "AZ", "BD", "BH", "BN", "CN", "GE", "HK", "ID", "IL", "IN", "IQ", "IR", "JO", "JP", "KG", "KH", "KP", "KR", "KW", "KZ", "LA", "LB", "LK", "MM", "MN", "MO", "MV", "MY", "NP", "OM", "PH", "PK", "QA", "SA", "SG", "SY", "TH", "TJ", "TM", "TW", "UZ", "VN", "YE"),   
  "Africa" = c("AO", "BF", "BI", "BJ", "BW", "CD", "CF", "CG", "CI", "CM", "CV", "DJ", "DZ", "EG", "EH", "ER", "ET", "GA", "GH", "GM", "GN", "GQ", "GW", "KE", "KM", "LR", "LS", "LY", "MA", "MG", "ML", "MR", "MU", "MW", "MZ", "NA", "NE", "NG", "RE", "RW", "SC", "SD", "SH", "SL", "SN", "SO", "ST", "SZ", "TD", "TG", "TN", "TZ", "UG", "YT", "ZA", "ZM", "ZW"), 
  "Oceania" = c("AU", "FJ", "FM", "GU", "KI", "MH", "MP", "NC", "NF", "NR", "NU", "NZ", "PF", "PG", "PN", "PW", "SB", "TK", "TO", "TV", "UM", "VU", "WF", "WS"))

df$company_region <- as.factor(df$company_location)
levels(df$company_region) <- list(  
  "North America" = c("US", "CA", "MX"),   
  "South America" = c("AR", "BO", "BR", "CL", "CO", "EC", "PE", "PY", "UY", "VE"),   
  "Central America" = c("BZ", "CR", "DO", "GT", "HN", "NI", "PA", "PR", "SV"),
  "Europe" = c("AT", "AL", "AX", "BE", "BG", "CH", "CY", "CZ", "DE", "DK", "EE", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IS", "IT", "JE", "LT", "LU", "LV", "MD", "MT", "NL", "NO", "PL", "PT", "RO", "RU", "RS", "SE", "SI", "SK", "TR", "UA"),
  "Asia" = c("AE", "AF", "AM", "AZ", "BD", "BH", "BN", "CN", "GE", "HK", "ID", "IL", "IN", "IQ", "IR", "JO", "JP", "KG", "KH", "KP", "KR", "KW", "KZ", "LA", "LB", "LK", "MM", "MN", "MO", "MV", "MY", "NP", "OM", "PH", "PK", "QA", "SA", "SG", "SY", "TH", "TJ", "TM", "TW", "UZ", "VN", "YE"),   
  "Africa" = c("AO", "BF", "BI", "BJ", "BW", "CD", "CF", "CG", "CI", "CM", "CV", "DJ", "DZ", "EG", "EH", "ER", "ET", "GA", "GH", "GM", "GN", "GQ", "GW", "KE", "KM", "LR", "LS", "LY", "MA", "MG", "ML", "MR", "MU", "MW", "MZ", "NA", "NE", "NG", "RE", "RW", "SC", "SD", "SH", "SL", "SN", "SO", "ST", "SZ", "TD", "TG", "TN", "TZ", "UG", "YT", "ZA", "ZM", "ZW"), 
  "Oceania" = c("AU", "AS", "FJ", "FM", "GU", "KI", "MH", "MP", "NC", "NF", "NR", "NU", "NZ", "PF", "PG", "PN", "PW", "SB", "TK", "TO", "TV", "UM", "VU", "WF", "WS"))

summary(df)
```

```{r}
aux <- data.frame(matrix(0, nrow = length(levels(df$company_region)), ncol = length(levels(df$company_region))))
colnames(aux) <- levels(df$company_region)
rownames(aux) <- levels(df$company_region)

for (i in 1:nrow(aux)) {
  for (j in 1:ncol(aux)) {
    aux[i, j] <- length(which(df$company_region == colnames(aux)[j] & df$employee_region == rownames(aux)[i]))
  }
}

data_long <- aux %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")

nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())
 
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

sankeyNetwork(Links = data_long, Nodes = nodes,
                     Source = "IDsource", Target = "IDtarget",
                     Value = "value", NodeID = "name", 
                     sinksRight=FALSE, nodeWidth=40, fontSize=13, nodePadding=20)
```

```{r}
levels(factor(df$job_title))  
```

```{r}
df$industry <- ifelse( grepl("data", df$job_title, ignore.case = T), "DATA", "OTHER")
df$industry <- ifelse( grepl("machine", df$job_title, ignore.case = T), "ML/AI", df$industry)
df$industry <- ifelse( grepl("ML", df$job_title, ignore.case = T), "ML/AI", df$industry)
df$industry <- ifelse( grepl("AI", df$job_title, ignore.case = T), "ML/AI", df$industry)
df$industry <- as.factor(df$industry)

df$boss <- ifelse(grepl("head", df$job_title, ignore.case = T), TRUE, FALSE)
df$boss <- ifelse(grepl("lead", df$job_title, ignore.case = T), TRUE, df$boss)
df$boss <- ifelse(grepl("principal", df$job_title, ignore.case = T), TRUE, df$boss)
df$boss <- ifelse(grepl("director", df$job_title, ignore.case = T), TRUE, df$boss)

df$role <- ifelse(grepl("scientist", df$job_title, ignore.case = T), "SCIENTIST", "OTHER")
df$role <- ifelse(grepl("engineer", df$job_title, ignore.case = T), "ENGINEER", df$role)
df$role <- ifelse(grepl("analyst", df$job_title, ignore.case = T), "ANALYST", df$role)
df$role <- ifelse(grepl("manager", df$job_title, ignore.case = T), "MANAGER", df$role)
df$role <- ifelse(grepl("architect", df$job_title, ignore.case = T), "ARCHITECT", df$role)
df$role <- ifelse(grepl("developer", df$job_title, ignore.case = T), "DEVELOPER", df$role)
df$role <- as.factor(df$role)

df$research <- ifelse(grepl("research", df$job_title, ignore.case = T), TRUE, FALSE)

summary(df)

```
```{r}
mean(df$salary_in_usd)
mean(df[df$boss == 'NO', 'salary_in_usd'])
mean(df[df$boss == 'YES', 'salary_in_usd'])
```

```{r}
numerics_names <- colnames(df[, sapply(df, is.numeric)])
factors_names <- colnames(df[, sapply(df, is.factor)])

for (i in 1:length(numerics_names)){
  print(ggplot(df, aes_string(x= numerics_names[i])) +
    ggdist::stat_halfeye(
      adjust=0.5,
      justification = -.2,
      .width=0
    ) +
    geom_boxplot(
      width = .1,
      alpha = 0.5
    ) +
     labs(title=paste("Distribution and boxplot of",numerics_names[i]), y="count"))
}

for (i in 1:length(factors_names)){
  print(ggplot(df, aes_string(x= factors_names[i])) +
    geom_bar()+
     labs(title=paste("Histogram of",factors_names[i]),y="count"))
}
```

```{r}
plot(df$employee_residence, df$salary_in_usd, xlab="Employee Residence", ylab="Salary in USD")
plot(df$company_size, df$salary_in_usd, xlab="Company Size", ylab="Salary in USD")
plot(df$company_location, df$salary_in_usd, xlab="Company Location", ylab="Salary in USD")
plot(df$experience_level, df$salary_in_usd, xlab="Experience Level", ylab="Salary in USD")
plot(df$remote_ratio, df$salary_in_usd, xlab="Remote Ratio", ylab="Salary in USD")
```

```{r}

y_2020 <- df[df$work_year == 2020,]
y_2021 <- df[df$work_year == 2021,]
y_2022 <- df[df$work_year == 2022,]

y_2020 <- y_2020 %>% group_by(remote_ratio) %>% summarise(count = n())
y_2021 <- y_2021 %>% group_by(remote_ratio) %>% summarise(count = n())
y_2022 <- y_2022 %>% group_by(remote_ratio) %>% summarise(count = n())

y_2020$percentage <- y_2020$count / sum(y_2020$count) * 100
y_2021$percentage <- y_2021$count / sum(y_2021$count) * 100
y_2022$percentage <- y_2022$count / sum(y_2022$count) * 100

y_2020$work_year <- 2020
y_2021$work_year <- 2021
y_2022$work_year <- 2022

y <- rbind(y_2020, y_2021, y_2022)

ggplot(y, aes(x = work_year, y = percentage, group = remote_ratio, color = remote_ratio)) + geom_line() + geom_point() + labs(x = "Work Year", y = "Percentage of Remote Ratio", title = "Remote Ratio by Work Year") + theme(plot.title = element_text(hjust = 0.5))
```

# Questions

## 1. 
## 2. 
## 3. 
## 4. How much more are seniors/experts paid than junior developers?

This could be useful for employees that are going to recieve a promotion, and want
to know how much they should get paid for their new position.
It could also be useful for employers that want to know how much they should offer
new hires or promoting employees.

```{r}
f <- ggplot(df, aes(x=reorder(experience_level,salary_in_usd), y=salary_in_usd))+
     geom_boxplot()
f
```
As we can see, from ENtry level to EXpert level, as the experience increases, the larger the average salary gets. Lets see if we can find, using clustering, 3 zones for each


```{r}
set.seed(42)
dfEN = df[df$experience_level=='EN',]
quantiles <- quantile(dfEN$salary_in_usd, c(0.05,0.95))
dfEN <- dfEN[dfEN$salary_in_usd > quantiles[1] & dfEN$salary_in_usd < quantiles[2],]
dfEN <- dfEN[c('salary_in_usd')]
clsEN <- kmeans(x=dfEN, centers=3)
dfEN$cluster <- as.character(clsEN$cluster)
f <- ggplot(data=dfEN,mapping=aes(x='EN',y=salary_in_usd))+
  geom_violin(scale="count")+
  geom_point(aes(colour=cluster))
f

dfMI = df[df$experience_level=='MI',]
quantiles <- quantile(dfMI$salary_in_usd, c(0.05,0.95))
dfMI <- dfMI[dfMI$salary_in_usd > quantiles[1] & dfMI$salary_in_usd < quantiles[2],]
dfMI <- dfMI[c('salary_in_usd')]
clsMI <- kmeans(x=dfMI, centers=3)
dfMI$cluster <- as.character(clsMI$cluster)
f <- ggplot(data=dfMI,mapping=aes(x='EN',y=salary_in_usd))+
  geom_violin(scale="count")+
  geom_point(aes(colour=cluster))
f

dfSE = df[df$experience_level=='SE',]
quantiles <- quantile(dfSE$salary_in_usd, c(0.05,0.95))
dfSE <- dfSE[dfSE$salary_in_usd > quantiles[1] & dfSE$salary_in_usd < quantiles[2],]
dfSE <- dfSE[c('salary_in_usd')]
clsSE <- kmeans(x=dfSE, centers=3)
dfSE$cluster <- as.character(clsSE$cluster)
f <- ggplot(data=dfSE,mapping=aes(x='EN',y=salary_in_usd))+
  geom_violin(scale="count")+
  geom_point(aes(colour=cluster))
f

dfEX = df[df$experience_level=='EX',]
quantiles <- quantile(dfEX$salary_in_usd, c(0.05,0.95))
dfEX <- dfEX[dfEX$salary_in_usd > quantiles[1] & dfEX$salary_in_usd < quantiles[2],]
dfEX <- dfEX[c('salary_in_usd')]
clsEX <- kmeans(x=dfEX, centers=3)
dfEX$cluster <- as.character(clsEX$cluster)
f <- ggplot(data=dfEX,mapping=aes(x='EN',y=salary_in_usd))+
  geom_violin(scale="count")+
  geom_point(aes(colour=cluster))
f
```

Lets try to find the mean salary for each middle cluster per experience level:

```{r}
entry_fair_mean = mean(dfEN$salary_in_usd[dfEN$cluster==2])
middle_fair_mean = mean(dfMI$salary_in_usd[dfMI$cluster==2])
senior_fair_mean = mean(dfSE$salary_in_usd[dfSE$cluster==2])
expert_fair_mean = mean(dfEX$salary_in_usd[dfEX$cluster==2])

entry_fair_mean
middle_fair_mean
senior_fair_mean
expert_fair_mean
```

These values indicate the average salary for each experience level of employees that are fairly paid (not underpaid nor overpaid). Now we will try to find the salary increase from one experience level to another.


```{r}
entry_to_middle_increase_absolute = middle_fair_mean - entry_fair_mean
middle_to_senior_increase_absolute  = senior_fair_mean - middle_fair_mean
senior_to_expert_increase_absolute  = expert_fair_mean - senior_fair_mean

entry_to_middle_increase_absolute
middle_to_senior_increase_absolute
senior_to_expert_increase_absolute
```


```{r}
entry_to_middle_increase_relative = (((entry_fair_mean+entry_to_middle_increase_absolute)/entry_fair_mean)-1)
middle_to_senior_increase_relative = (((middle_fair_mean+middle_to_senior_increase_absolute)/middle_fair_mean)-1)
senior_to_expert_increase_relative = (((senior_fair_mean+senior_to_expert_increase_absolute)/senior_fair_mean)-1)

cat(entry_to_middle_increase_relative*100,"%\n")
cat(middle_to_senior_increase_relative*100,"%\n")
cat(senior_to_expert_increase_relative*100, "%\n")
```

The first four values indicate the mean salary of the fairly paid group for each experience level. Using those values, we find the average salary increase from one role to another. As we can see



## 5. Do bigger companies pay more to their employees?
## 6. 
 
## 7. Can we predict which employees are at risk of leaving their company?

This could be useful for companies who want to retain their top talent and for employees that are underpaid. We could use different factors such to determine which employees are underpaid compared to their peers.

To answer this questions we will use two different techniques: Clustering and regression.

The following features will be used:
 - Experience level
 - Employment type
 - Industry
 - Employee region
 - Role
 - Remote_ratio
 - Boss
 - Research
 - Company size

### Clustering

First we create a separate dataframe for the variables we will use.
```{r}
# Select the variables to use in the clustering analysis
df_vars <- select(df, experience_level, employment_type, company_size, industry, employee_region, boss, research, role, remote_ratio)
                    
df_vars$experience_level <- as.numeric(df_vars$experience_level)
df_vars$industry <- as.numeric(df_vars$industry)
df_vars$employment_type <- as.numeric(df_vars$employment_type)
df_vars$company_size <- as.numeric(df_vars$company_size)
df_vars$employee_region <- as.numeric(df_vars$employee_region)
df_vars$role <- as.numeric(df_vars$role)
df_vars$boss <- as.numeric(df_vars$boss)
df_vars$research <- as.numeric(df_vars$research)
df_vars$remote_ratio <- as.numeric(df_vars$remote_ratio)

# Standardize the variables
df_vars <- scale(df_vars)

```

Let s find find the elbow in our plot, to find the "best" k for the kmeans algorithm
```{r}
results <- data.frame(k = integer(), WCSS = double())

# Loop through a range of values for k
for (k in 2:100) {
  # Run the k-means clustering algorithm
  km <- kmeans(df_vars, k, nstart = 10)
  # Store the results in the data frame
  results <- rbind(results, data.frame(k = k, WCSS = km$tot.withinss))
}

# Plot the WCSS values for each value of k
ggplot(results, aes(x = k, y = WCSS)) +
  geom_line() +
  geom_point() +
  labs(x = "Number of clusters (k)", y = "WCSS")
```

```{r}
# Perform k-means clustering with 3 clusters
kmeans_results <- kmeans(df_vars, 20)

df_Q7 <- df
# Add the cluster labels to the original data
df_Q7$cluster <- kmeans_results$cluster

# Inspect the clusters
group_by(df_Q7, cluster) %>%
  summarize(mean_salary = mean(salary_in_usd))
```

```{r}
fig1 <- plot_ly(df_Q7, x = ~as.numeric(employee_region), y = ~as.numeric(industry), z = ~as.numeric(experience_level), color = ~cluster)
fig1 <- fig1 %>% add_markers()

axx <- list(ticketmode = 'array', title="Employee region", ticktext = levels(df$employee_region),  tickvals = c(1,2,3,4,5,6,7),  range = c(1,7), tickangle = 25)
axy <- list(ticketmode = 'array', title="Industry", ticktext = levels(df$industry),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)
axz <- list(ticketmode = 'array', title="Experience level", ticktext = levels(df$experience_level),  tickvals = c(1,2,3,4),  range = c(1,4), tickangle = 45)

fig1 <- fig1 %>% layout(scene = list(xaxis = axx, yaxis = axy, zaxis = axz))
fig1


fig2 <- plot_ly(df_Q7, x = ~as.numeric(role), y = ~as.numeric(industry), z = ~as.numeric(remote_ratio), color = ~cluster)
fig2 <- fig2 %>% add_markers()

axx <- list(ticketmode = 'array', title="Role", ticktext = levels(df$role),  tickvals = c(1,2,3,4,5,6,7),  range = c(1,7), tickangle = 25)
axy <- list(ticketmode = 'array', title="Industry", ticktext = levels(df$industry),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)
axz <- list(ticketmode = 'array', title="Remote ratio", ticktext = levels(df$remote_ratio),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)

fig2 <- fig2 %>% layout(scene = list(xaxis = axx, yaxis = axy, zaxis = axz))
fig2


fig3 <- plot_ly(df_Q7, x = ~as.numeric(role), y = ~as.numeric(industry), z = ~as.numeric(remote_ratio), color = ~cluster)
fig3 <- fig3 %>% add_markers()

axx <- list(ticketmode = 'array', title="Role", ticktext = levels(df$role),  tickvals = c(1,2,3,4,5,6,7),  range = c(1,7), tickangle = 25)
axy <- list(ticketmode = 'array', title="Industry", ticktext = levels(df$industry),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)
axz <- list(ticketmode = 'array', title="Remote ratio", ticktext = levels(df$remote_ratio),  tickvals = c(1,2,3),  range = c(1,3), tickangle = 45)

fig3 <- fig3 %>% layout(scene = list(xaxis = axx, yaxis = axy, zaxis = axz))
fig3

```

```{r}
mean_salary <- tapply(df_Q7$salary_in_usd, df_Q7$cluster, mean)
# View the mean salary for each level of the experience_level variable
df_Q7$salary_difference_kmeans <- 0
df_Q7$predicted_salary_kmeans <-0

for (i in 1:nrow(df_Q7)) {
  cluster_index = match(df_Q7$cluster[i], names(mean_salary))
  df_Q7$salary_difference_kmeans[i] <- df_Q7$salary_in_usd[i] - mean_salary[cluster_index]
  df_Q7$predicted_salary_kmeans[i] <- mean_salary[cluster_index]
}

underpaid_employees_kmeans <- df_Q7[df_Q7$salary_difference_kmeans < 0, ]
overpaid_employees_kmeans <- df_Q7[df_Q7$salary_difference_kmeans > 0, ]

underpaid_employees_kmeans <- underpaid_employees_kmeans[order(underpaid_employees_kmeans$salary_difference_kmeans), ]
overpaid_employees_kmeans <- overpaid_employees_kmeans[order(overpaid_employees_kmeans$salary_difference_kmeans, decreasing = TRUE), ]

# View the underpaid and overpaid employees
head(underpaid_employees_kmeans, n = 10)
head(overpaid_employees_kmeans, n=10)
```

```{r}
model <- lm(salary_in_usd ~ experience_level + employment_type + employee_region + company_size + industry + role + boss + research + remote_ratio, data = df_Q7)
summary(model)
```

```{r}
df_Q7$predicted_salary_lm  <- predict(model, newdata = df_Q7)
df_Q7$salary_difference_lm <- df_Q7$salary_in_usd - df_Q7$predicted_salary_lm

# Use the salary difference column to identify underpaid and overpaid employees
underpaid_employees_lm <- df_Q7[df_Q7$salary_difference_lm < 0, ]
overpaid_employees_lm <- df_Q7[df_Q7$salary_difference_lm > 0, ]

underpaid_employees_lm <- underpaid_employees_lm[order(underpaid_employees_lm$salary_difference_lm), ]
overpaid_employees_lm <- overpaid_employees_lm[order(overpaid_employees_lm$salary_difference_lm, decreasing = TRUE), ]

# View the underpaid and overpaid employees
head(underpaid_employees_lm, n = 10)
head(overpaid_employees_lm, n=10)
```

```{r}
df_Q7$kmeans_ratio_error <- ((df_Q7$predicted_salary_kmeans / df_Q7$salary_in_usd)-1)*100
df_Q7$lm_ratio_error <- ((df_Q7$predicted_salary_lm / df_Q7$salary_in_usd)-1)*100

summary(df_Q7[, c("kmeans_ratio_error","lm_ratio_error")])
```

```{r}
df_Q7 <- df_Q7[order(df_Q7$salary_in_usd),]
# Add a column to the dataframe with a sequence of integers
x <- 1:nrow(df_Q7)

df_Q7$status_lm <- ifelse(df_Q7$lm_ratio_error < -17.07, "Overpaid", 
                      ifelse(df_Q7$lm_ratio_error < 32.4, "Normal", "Underpaid"))

df_Q7$status_kmeans <- ifelse(df_Q7$kmeans_ratio_error < -18.88, "Overpaid", 
                      ifelse(df_Q7$kmeans_ratio_error < 40.26, "Normal", "Underpaid"))
```

```{r}
ggplot(df_Q7, aes(x = x, y = salary_in_usd)) +
        geom_point(aes(y = salary_in_usd), size= 2, shape = 20) +
        geom_point(aes(y = predicted_salary_lm, color = status_lm), size =2,  shape = 20, alpha = 0.9) + 
        scale_color_manual(
          values = c("Overpaid" = "red", "Underpaid" = "orange", "Normal" = "green"), 
          labels = c('Normal', 'Overpaid', 'Underpaid'),
          aesthetics = c("colour", "fill"), 
          name = "Consideration") +
        ggtitle("Plot of salary and predicted salaries using Linear Regression") +
        ylab("Salary in USD") +
        scale_y_continuous(labels = label_comma(), breaks = scales::pretty_breaks(n = 10))
        

ggplot(df_Q7, aes(x = x, y = salary_in_usd)) +
        geom_point(aes(y = salary_in_usd), size= 2, shape = 20) +
        geom_point(aes(y = predicted_salary_kmeans, color = status_kmeans), size =2,  shape = 20, alpha = 0.9) + 
        scale_color_manual(
          values = c("Overpaid" = "red", "Underpaid" = "orange", "Normal" = "green"), 
          labels = c('Normal', 'Overpaid', 'Underpaid'),
          aesthetics = c("colour", "fill"),
          name = "Consideration") +
        ggtitle("Plot of salary and predicted salaries using Clustering") +
        ylab("Salary in USD") +
        labs(fill="Consideration") +
        scale_y_continuous(labels = label_comma(), breaks = scales::pretty_breaks(n = 10))


```

```{r}
df_Q7$status_lm <- as.factor(df_Q7$status_lm)
df_Q7$status_kmeans <- as.factor(df_Q7$status_kmeans)


ct <- table(df_Q7$status_lm,df_Q7$status_kmeans)
ct <- ct[c(3,1,2),c(3,1,2)]
ct <- melt(ct)
colnames(ct) <- c("LinearRegression", "Clustering", "Count")

ggplot(ct, aes(x = LinearRegression, y = Clustering, fill = Count)) +
  geom_tile() +
  scale_fill_gradient2(low = "#075AFF", mid = "#FFFFCC", high = "#FF0000") +
  geom_text(aes(label = Count), color = "black", size = 4) +
  coord_fixed() +
  ggtitle("Comparison between Clustering and Linear Regression") 

```

```{r}
underpaid_lm <- df_Q7[df_Q7$status_lm=="Underpaid",]
overpaid_lm <- df_Q7[df_Q7$status_lm=="Overpaid",]

underpaid_kmeans <- df_Q7[df_Q7$status_kmeans =="Underpaid",]
overpaid_kmeans  <- df_Q7[df_Q7$status_kmeans =="Overpaid",]
```

```{r}

variables <- c("experience_level", "remote_ratio", "salary_group", "employee_region", "company_region", "role", "boss", "research", "company_size", "industry")

for (i in 1:length(variables)){
  ratio_df <- table(df_Q7[, c(variables[i])])/nrow(df_Q7)
  ratio_up_lm <- table(underpaid_lm[, c(variables[i])])/nrow(underpaid_lm)
  ratio_op_lm <- table(overpaid_lm[, c(variables[i])])/nrow(overpaid_lm)

  # plot them in such a way that they can be compared
  df_long_lm <- melt(data.frame(ratio_up_lm, ratio_df, ratio_op_lm))
  
  ratio_up_kmeans <- table(underpaid_kmeans[, c(variables[i])])/nrow(underpaid_kmeans)
  ratio_op_kmeans <- table(overpaid_kmeans[, c(variables[i])])/nrow(overpaid_kmeans)

  # plot them in such a way that they can be compared
  df_long_kmeans <- melt(data.frame(ratio_up_kmeans, ratio_df, ratio_op_kmeans))

  print(ggplot(data = df_long_lm, aes(x = variable, y = value , fill = Var1, label = round(value, 2))) +
    geom_bar(stat = "identity", position = "fill") +
    geom_text(size = 3, position = position_stack(vjust = 0.5)) +
    scale_x_discrete(labels = c("Freq"= "Underpaid", "Freq.1"= "Normal", "Freq.2" = "Overpaid")) +
    labs(fill=variables[i], title=paste("Stacked percent bar chart of ",variables[i], " (LM)"), x="Consideration", y = "%"))
  
   print(ggplot(data = df_long_kmeans, aes(x = variable, y = value , fill = Var1, label = round(value, 2))) +
    geom_bar(stat = "identity", position = "fill") +
    geom_text(size = 3, position = position_stack(vjust = 0.5)) +
    scale_x_discrete(labels = c("Freq"= "Underpaid", "Freq.1"= "Normal", "Freq.2" = "Overpaid")) +
    labs(fill=variables[i], title=paste("Stacked percent bar chart of ",variables[i], " (Clustering)"), x="Consideration", y = "%"))
}

```

## 8.
## 9. 
## 10. 
## 11. 
## 12.
## 13. Can we identify salary disparities based on residence and other demographic factors?

For this we'll use visualization techniques with the ggplot library. The width of the boxes depends on the amount of samples each class/value has so we can extract better conclusions out of them.
```{r}
ggplot(df, aes(x = as.factor(work_year), y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the work year", x = "Year", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = experience_level, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the experience level", x = "Experience level", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = employment_type, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the employment type", x = "Employment type", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = employee_region, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the employee region of residence", x = "Region of residence", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = company_size, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the company size", x = "Company size", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = role, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the role", x = "Role", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = industry, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on the industry", x = "Industry", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = boss, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on whether the employee has a leadership position", x = "Has a leadership position", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())

ggplot(df, aes(x = research, y = salary_in_usd)) +
         geom_boxplot(varwidth=T, fill="lightblue") +
         labs(title = "Salary depending on whether the employee participates in research projects", x = "Works in research projects", y = "Salary in USD") +
         theme_minimal() + 
         scale_y_continuous(labels = scales::dollar_format())
```

Let's go through the different plots and check if we can identify any disparity:

  - Work year: we can observe how the salaries seem to be growing year by year - mostly in 2022. Probably due to the inflation rates. Further we can check which is the amount of growth in salaries discounting the inflation.
  - Experience level: as expected, more experienced professionals earn a higher salary.
  - Employment type: we can't say much about contract, freelance or part time jobs since the amount of samples we have is quite reduced; but probably contracts generate higher revenue than a full time job.
  - Employee region of residence: we can observe how the income in north american countries is higher than in the other regions, can't say much about other regions apart of NA and Europe since the dataset is mostly composed of these regions data.
  - Company size: we can clearly see that smaller companies usually offer lower salaries while medium and large companies have higher wages. The difference between medium and large ones is mostly the same but the impressive salaries usually come from large enterprises (makes sense think about Google, Meta, Netflix, Amazon...).
  - Role: better paid roles are architects, engineers, managers and scientists while developers have the lower wages from all the roles.
  - Industry: in terms of the company industry we can't say much about it since data and ML/AI companies are quite similar when it comes to wages.
  - Leadership position: we can clearly observe how having a leadership position in the company usually implies a higher salary in return.
  - Involved in research projects: on the other hand, participating in research projects seems to be not so interesting, at least from the financial perspective, since most other people earn higher salaries than the ones that participate in this kind of projects.

## 14. 
## 15. 
